{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j] Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Introducci\u00f3n"},{"location":"#introduccion","text":"For full documentation visit mkdocs.org .","title":"Introducci\u00f3n"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. def bubble_sort(items): for i in range(len(items)): for j in range(len(items) - 1 - i): if items[j] > items[j + 1]: items[j], items[j + 1] = items[j + 1], items[j]","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Archivos/","text":"Archivos del programa A continuaci\u00f3n, se proceder\u00e1 a explicar las funciones que se desarrollan en los archivos. 1. City.cpp En esta secci\u00f3n se encuentran los m\u00e9todos de la clase City City() El constructor de la clase City recibe y guarda en sus atributos el nombre de la ciudad, sus coordenadas en el eje x y sus coordenadas en el eje y. City::City(std::string name, int x, int y){ x_=x; y_=y; name_=name; } getx() Devuelve el valor del atributo x, es decir, las coordenadas en el eje x de la ciudad en cuesti\u00f3n. int City::getx(){ return x_; } gety() Devuelve el valor del atributo y, es decir, las coordenadas en el eje y de la ciudad en cuesti\u00f3n. int City::gety(){ return y_; } getname() Devuelve el valor del atributo name, es decir, el nombre de la ciudad en cuesti\u00f3n. std::string City::getname(){ return name_; } distanceTo() Calcula la distancia entre dos ciudades. Por ejemplo, si yo quiero saber la distancia entre a y b ejecutaria la funci\u00f3n de la siguiente manera: a.distanceTo(&b) float City::DistanceTo( City* b){ float xDis= abs(x_-b->getx()); float yDis= abs(y_-b->gety()); float distance= sqrt(pow(xDis, 2)+pow(yDis, 2)); return distance; } Lectura.cpp En esta secci\u00f3n se encuentran los m\u00e9todos de la clase City open() La funci\u00f3n open recibe el nombre de un archivo como string. Recorre cada l\u00ednea del archivo, omitiendo aquellas que comiencen con #. En primer lugar, de cada l\u00ednea le\u00edda se verifica en que posiciones se encuentran los separadores (espacio, coma o tabulaci\u00f3n) y el largo de la l\u00ednea. En segundo lugar, se calcula y se guarda en determinadas variables los datos de las ciudades: nombre, coordenadas en el eje x y coordenadas en el eje y, en el respectivo orden. Por \u00faltimo, se crea una ciudad con los par\u00e1metros obtenidos del archivo agreg\u00e1ndola en un vector de ciudades. Esto se repetir\u00e1 con todas las l\u00edneas del archivo, hasta que llegue al final u ocurra un error. Al finalizar el ciclo de lectura, el archivo se cierra y la funci\u00f3n devuelve el vector de ciudades. std::vector<City> File::open(std::string arc){ std::ifstream myfile(arc); while(getline(myfile, linea_)){ if (linea_[0]!= '#'){ first_ =linea_.find_first_of(\" ,\"); last_= linea_.find_last_of(\" ,\"); size_= linea_.size(); std::string name = linea_.substr(0, first_); std::string x=linea_.substr(first_+1, last_-(first_+1)); std::string y=linea_.substr(last_+1, size_-last_); City city(name, stoi(x), stoi(y)); cities.emplace_back(city); } } myfile.close(); return cities; }","title":"Archivos"},{"location":"Archivos/#archivos-del-programa","text":"A continuaci\u00f3n, se proceder\u00e1 a explicar las funciones que se desarrollan en los archivos.","title":"Archivos del programa"},{"location":"Archivos/#1-citycpp","text":"En esta secci\u00f3n se encuentran los m\u00e9todos de la clase City","title":"1. City.cpp"},{"location":"Archivos/#city","text":"El constructor de la clase City recibe y guarda en sus atributos el nombre de la ciudad, sus coordenadas en el eje x y sus coordenadas en el eje y. City::City(std::string name, int x, int y){ x_=x; y_=y; name_=name; }","title":"City()"},{"location":"Archivos/#getx","text":"Devuelve el valor del atributo x, es decir, las coordenadas en el eje x de la ciudad en cuesti\u00f3n. int City::getx(){ return x_; }","title":"getx()"},{"location":"Archivos/#gety","text":"Devuelve el valor del atributo y, es decir, las coordenadas en el eje y de la ciudad en cuesti\u00f3n. int City::gety(){ return y_; }","title":"gety()"},{"location":"Archivos/#getname","text":"Devuelve el valor del atributo name, es decir, el nombre de la ciudad en cuesti\u00f3n. std::string City::getname(){ return name_; }","title":"getname()"},{"location":"Archivos/#distanceto","text":"Calcula la distancia entre dos ciudades. Por ejemplo, si yo quiero saber la distancia entre a y b ejecutaria la funci\u00f3n de la siguiente manera: a.distanceTo(&b) float City::DistanceTo( City* b){ float xDis= abs(x_-b->getx()); float yDis= abs(y_-b->gety()); float distance= sqrt(pow(xDis, 2)+pow(yDis, 2)); return distance; }","title":"distanceTo()"},{"location":"Archivos/#lecturacpp","text":"En esta secci\u00f3n se encuentran los m\u00e9todos de la clase City","title":"Lectura.cpp"},{"location":"Archivos/#open","text":"La funci\u00f3n open recibe el nombre de un archivo como string. Recorre cada l\u00ednea del archivo, omitiendo aquellas que comiencen con #. En primer lugar, de cada l\u00ednea le\u00edda se verifica en que posiciones se encuentran los separadores (espacio, coma o tabulaci\u00f3n) y el largo de la l\u00ednea. En segundo lugar, se calcula y se guarda en determinadas variables los datos de las ciudades: nombre, coordenadas en el eje x y coordenadas en el eje y, en el respectivo orden. Por \u00faltimo, se crea una ciudad con los par\u00e1metros obtenidos del archivo agreg\u00e1ndola en un vector de ciudades. Esto se repetir\u00e1 con todas las l\u00edneas del archivo, hasta que llegue al final u ocurra un error. Al finalizar el ciclo de lectura, el archivo se cierra y la funci\u00f3n devuelve el vector de ciudades. std::vector<City> File::open(std::string arc){ std::ifstream myfile(arc); while(getline(myfile, linea_)){ if (linea_[0]!= '#'){ first_ =linea_.find_first_of(\" ,\"); last_= linea_.find_last_of(\" ,\"); size_= linea_.size(); std::string name = linea_.substr(0, first_); std::string x=linea_.substr(first_+1, last_-(first_+1)); std::string y=linea_.substr(last_+1, size_-last_); City city(name, stoi(x), stoi(y)); cities.emplace_back(city); } } myfile.close(); return cities; }","title":"open()"},{"location":"muestras/","text":"","title":"Muestras"}]}